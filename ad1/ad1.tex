\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[usenames]{xcolor}
\newcommand{\ub}[1]{\textcolor{blue}{#1}}
\newcommand{\ubc}[1]{\textcolor{brown}{#1}}

\begin{document}
\title{Übersicht Aufgaben AD1}
\author{Florian Bruhin}
\maketitle

\section{Rekursion}

\begin{itemize}
  \item \ub{PP5}: Rekursion-Trace
  \item \ub{U1.1, U1.2}: Basics (TextAnalyse)
  \item \ubc{U2.3}: Greedy (Münzausgabe)
  \item \ubc{U5.1}: Einfache Rekursion (SumSquare)
  \item \ubc{U5.2}: Suche in geordneter Liste (BinarySearch)
  \item \ubc{U5.3}: Von Koch Fraktal
  \item \ubc{U5.4}: Hanoi-Türme
  \item \ubc{U6.1}: Rekursion vs. Iteration (SumOddNumbers)
  \item \ubc{U9.1}: Labyrinth-Backtracking
  \item \ubc{2015-5}: Rekursive Ausgabe von Node List
\end{itemize}

\section{Arithmetische Folgen/Reihen}
\begin{itemize}
  \item \ub{PP2}: Folge: Glied bestimmen rekursiv/iterativ/explizit
  \item \ub{U1.3, U2.1}: Folge: Glied bestimmen rekursiv/iterativ/explizit
  \item \ub{U1.4, U2.2}: Folge: Summenformel rekursiv/iterativ/explizit
\end{itemize}

\pagebreak
\section{O-Notation}
\begin{itemize}
  \item \ub{PP3}: Verschachtelte for-Loop, Laufzeit explizit/O-Notation mit Summenformel
  \item \ub{PP4}: Zeitverhalten Linked List (umgangssprachlich)
  \item \ub{PP9}: Zu erwartende Laufzeit von Array-Sortierung
  \item \ub{U2.4}: Verschachtelte for-loop, Laufzeit explizit/O-Notation
  \item \ub{U2.5}: Verschachtelte for-loop, Laufzeit explizit/O-Notation mit Summenformel
  \item \ub{U2.6}: Produkt zweier n*m-Matrizen
  \item \ub{U3.1b}: Paar-Summen - Algorithmus und Laufzeit explizit/O-Notation
    mit Summenformel
  \item \ub{U4.4}: Diverse Beweise, auch mit = und Theta
  \item \ub{U10.2c}: Rekursionsgleichung mit Vollständiger Induktion
  \item \ub{2005-3}: Zeitverhalten Insertion/Selection sort
  \item \ub{2015-4}: O-Abschätzung, Bestimmung ob in O(n) oder O($n^2$)
  \item \ub{2015-7.2}: Zeitverhalten von Iterator
\end{itemize}

\section{Vollständige Induktion}
\begin{itemize}
  \item \ub{U3.2, U3.3}: Explizite Summenformel beweisen (allgemein; mit Werten)
  \item \ub{U4.1}: Wiederholung für Summenformel
  \item \ub{U4.3}: Beweis mit zwei Sigmas
  \item \ub{2005-1}: Beweis mit log
\end{itemize}

\section{Programmieren}
\begin{itemize}
  \item \ub{PP1}: Output mit subclassing, references, etc.
  \item \ubc{PP12}: Sentinel-Trick implementieren
  \item \ubc{U1.2c}: TextAnalyse
  \item \ubc{U3.1acd}: Paar-Summen - Implementation
  \item \ubc{U3.4}: Adapter Pattern (Bike-Example)
  \item \ubc{U4.2}: Adapter Pattern (Vektor/Matrix)
  \item \ubc{2005-2}: Klassen-Adapter implementieren
  \item \ubc{2015-1}: Shadowing/Output mit Subclassing
  \item \ubc{2015-2/2015-3.1}: OO-Fragen
\end{itemize}

\section{Linked lists}
\begin{itemize}
  \item \ubc{U7.1a}: numNodes rekursiv
  \item \ubc{U7.1b}: concat
  \item \ubc{U7.1c}: reverse iterativ/rekursiv
  \item \ubc{2005-4}: Binary search
  \item \ubc{2015-3.2}: Hat singly linked list eine Schlaufe?
  \item \ub{2015-7.1}: ``Was macht dieser Code''
\end{itemize}

\section{Stack}
\begin{itemize}
  \item \ub{PP6}: Stack - welche Implementation mit Zeitvorgaben?
  \item \ub{U6.2}: Züge umordnen in Sackbahnhof via Stack
  \item \ubc{U6.3}: Stacks: span1/span2
  \item \ubc{U8.1a}: Stack mit linked list
  \item \ubc{2015-6.1}: Stack, minimales Element auslesen ohne Entfernen
\end{itemize}

\section{Queues}
\begin{itemize}
  \item \ubc{U7.2}: Deque mit Double Linked Lists; Speicherbedarf
  \item \ubc{U8.1b}: Queue mit Array
  \item \ubc{U8.2}: Permutationen mit Queue und Stack
  \item \ub{2015-6.2}: ``Was macht dieser Code''
\end{itemize}

\section{PQ/Heaps}
\begin{itemize}
  \item \ub{PP10}: Heap-basierte PQ: heap nach insert/removeMin
  \item \ub{PP11}: Heap-basierte adaptable PQ: heap nach replaceKey/replaceValue
  \item \ubc{U11.1}: In-place insertion sort mit PQ
  \item \ubc{U11.2}: LandingOrder mit PQ
  \item \ub{U12.1a}: Heap-Aufbau mit insert
  \item \ub{U12.1b}: Heap und removeMin
  \item \ubc{U12.2}: Heap-basierte PQ
  \item \ubc{U12.3}: Adaptable PQ
  \item \ub{2015-9.1}: Heaps zeichnen nach Einfügen/entfernen, Traversierung
\end{itemize}

\section{Bäume}
\begin{itemize}
  \item \ub{PP7}: Ausgabe bei Baum-Traversierung
  \item \ubc{PP8}: Array-basierter Binärbaum: height
  \item \ub{U9.2a}: Wie viele Binärbäume aus drei Knoten?
  \item \ub{U9.2b}: preorder/postorder/inorder, Reihenfolge
  \item \ubc{U10.1}: Binärbaum mit Vektor
  \item \ub{U10.2a}: Binärbaum, Beweis: Anzahl Kanten mit Knoten
  \item \ub{U10.2b}: Binärbaum, Beweis: Höhe mit Knoten
  \item \ubc{U11.3}: Huffman tree
  \item \ub{2015-8.1}: Wie viele Blattknoten mit internen Knoten
  \item \ub{2015-8.2-1}: in/pre/postorder Traversierung
  \item \ub{2015-8.2-2}: Was berechnet der Code?
  \item \ub{2015-8.3.1}: Array-Darstellung von Binärbaum (sieht wie aus?)
  \item \ubc{2015-8.3.2}: Level-Traversierung implementieren
\end{itemize}

\section{Maps/Hashes}
\begin{itemize}
  \item \ub{PP13}: Hash-Table mit double hashing
  \item \ubc{U13.1}: Map implementieren
  \item \ubc{U13.2}: UID-Generator via Map
  \item \ub{U13.3}: Hash-Tables mit verschiedenen Kollisionsverfahren
  \item \ub{U13.4}: Hash-Tables JavaDoc
  \item \ub{2015-10}: Hash-Table mit verschiedenen Hash-Funktionen
\end{itemize}

\section{Skiplisten}
\begin{itemize}
  \item \ub{U14.1}: Skipliste nach Einfügen angeben
  \item \ubc{U14.2}: Skipliste als Map - Objektdiagramm
  \item \ubc{U14.3}: Skipliste als Multimap
\end{itemize}

\end{document}